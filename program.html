<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- KATEX -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css" integrity="sha384-5TcZemv2l/9On385z///+d7MSYlvIEw9FuZTIdZ14vJLqWphw7e7ZPuOiCHJcFCP" crossorigin="anonymous">
    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js" integrity="sha384-cMkvdD8LoxVzGF/RPUKAcvmm49FQ0oxwDF3BGKtDXcEc+T1b2N+teh/OJfpU0jr6" crossorigin="anonymous"></script>
    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js" integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"
        onload="renderMathInElement(document.body);">
    </script>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          // customised options
          // • auto-render specific keys, e.g.:
          delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
            {left: '\\(', right: '\\)', display: false},
            {left: '\\[', right: '\\]', display: true}
          ],
          // • rendering keys, e.g.:
          throwOnError : false
        });
      });
    </script>
    <!-- KATEX -->
    <title>locus communis</title>
    <style>
        body {
            background-color: #333;
            color: #eee;
            font-family: monospace;
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column; /* Arrange items vertically */
            min-height: 100vh;
        }

        header {
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.6em;
        }

        .social-links {
            margin-top: 15px;
        }

        .social-links a {
            margin: 0 10px;
            color: #a7b3d6;
            text-decoration: none;
        }

        .social-links a:hover {
            text-decoration: underline;
        }

        div {
            max-width: 80ch; /* approximately 80 characters wide */
            padding: 20px;
            text-align: left; /* or text-align: justify; */
        }

        footer {
            margin-top: 20px;
            font-size: 0.8em;
            text-align: center;
        }


        a {
            color: #98a8d8; /* A soft blue for default links */
            text-decoration: none; /* Optional: Removes the default underline */
        }

        a:visited {
            color: #98a8d8; /* A light, desaturated blue-gray for visited links */
        }

        a:hover {
            text-decoration: underline;
        }

        .intro-snippet, .chapter-intro {
            margin-bottom: 1em;
            font-style:
            italic;
        }
        ol { margin-left: 2em; }
        li { margin-bottom: 0.5em; }
        .chapter { margin-bottom: 2.5em; }
    </style>
  </head>
  <body>
    <header>
      <h1><a href="./index.html">locus communis</a></h1>
    </header>
    <div>
      <h1>We are (not) wrong about databases!</h1>
      <p>Building a database category engine in Python from scratch!</p>

      <div class="intro-snippet">
          <p>Coders! data wranglers! and Python &#38; SQL developers! Ever feel like you're wrestling with data complexity, schema migrations, or ETL pipelines that feel... brittle? What if I told you there's a branch of abstract math, that offers a surprisingly powerful lens to understand and <em>design</em> better data systems? Forget dusty theorems for a moment.</p>
          <p>We're going on a practical journey, inspired by the work of <b>David I. Spivak</b>, to see how thinking in terms of objects, arrows, and compositions can make us (not) wrong about databases. We'll use <code>Python</code> and <code>SQLite</code>, reconnecting to concepts you already know, and build up intuition step-by-step. Ready to level up your thinking about data?</p>
      </div>

      <div class="chapter">
          <h2>1. Let's build a category in Python in 2 minutes! [Tomorrow 2025-04-28]</h2>
          <p class="chapter-intro">Forget the abstract definitions for a second. What if we could represent the <em>essence</em> of a category with just a few lines of Python? This chapter is about getting our hands dirty immediately, showing you that the core concepts aren't scary and can be coded faster than you can brew coffee.</p>
          <ol>
              <li><strong>What are we even talking about? Objects and Arrows:</strong> A super-quick, intuitive intro to the two fundamental building blocks. Think nodes and edges, but more general.</li>
              <li><strong>Your First Category:</strong> Defining a simple Python to hold objects and morphisms (arrows).</li>
              <li><strong>Composition: The Chain Reaction:</strong> Implementing the rule for how arrows follow each other (<code>g . f</code>). Why is this essential?</li>
              <li><strong>Identity: The "Do Nothing" Arrow:</strong> Adding the concept of an identity morphism for each object. The simplest, yet crucial, arrow.</li>
          </ol>
      </div>

      <div class="chapter">
          <h2>2. Sets are nodes? Functions are arrows? Why we need graphs anyway? [TBD]</h2>
          <p class="chapter-intro">You already know sets and functions. And you've seen graphs before. Let's connect these familiar ideas to our new category concept and understand <em>why</em> this graph-like thinking is so powerful for structuring information.</p>
          <ol>
              <li><strong>The Category $\mathcal{Set}$:</strong> Thinking of sets as objects and functions between sets as arrows. This is the category theorists' playground!</li>
              <li><strong>Visualizing Categories as Graphs:</strong> How the "objects and arrows" picture directly maps to directed graphs. Nodes are objects, edges are arrows.</li>
              <li><strong>Beyond Simple Graphs: Composition Matters:</strong> Why category theory adds the crucial layers of composition and identity on top of basic graph ideas.</li>
              <li><strong>Representing Relationships:</strong> How thinking in graphs/categories helps model connections between data points or tables naturally.</li>
          </ol>
      </div>

      <div class="chapter">
          <h2>3. Morphisms and Functors [TBD]</h2>
          <p class="chapter-intro">We've seen arrows ("morphisms") in action. Now let's formalize them slightly and introduce their equally important cousins: Functors. Functors are the "morphisms between categories," mapping one categorical structure to another while preserving the essential connections. Think of them as structure-preserving translations.</p>
          <ol>
              <li><strong>Morphisms Revisited: The Rules of the Road:</strong> Composition associativity $(h . g) . f = h . (g . f)$ and identity laws ($f . id = f$, $id . f = f$). Why these rules make the system work.</li>
              <li><strong>What's a Functor? Mapping Categories:</strong> Introducing the concept of a functor: mapping objects to objects and morphisms to morphisms consistently.</li>
              <li><strong>A Simple Python Functor Example:</strong> Maybe mapping a simple category we built to the category of $Set$ (e.g., representing graph nodes as sets of properties).</li>
              <li><strong>Why Functors Matter for Data:</strong> Hinting at how functors can model schema mappings, data migrations, or different views of the same underlying structure.</li>
          </ol>
      </div>

      <div class="chapter">
          <h2>4. <code>bool</code>, <code>int</code>, <code>str</code>, and <code>list</code>: The categories of one object. [TBD]</h2>
          <p class="chapter-intro">Okay, time to blow your mind a little. What if fundamental Python types like <code>bool</code> or <code>int</code> could be seen as categories themselves? This chapter explores how structures with just <em>one</em> object can still have rich internal structure represented by their morphisms (operations).</p>
          <ol>
              <li><strong>The Monoid: A Category with One Object:</strong> Introducing the algebraic structure of a monoid (a set with an associative operation and an identity element).</li>
              <li><strong><code>int</code> as a Monoid (under addition):</strong> Viewing integers as a single-object category where morphisms are additions.</li>
              <li><strong><code>str</code> as a Monoid (under concatenation):</strong> Similarly, seeing strings with concatenation $+$ and the empty string <code>""</code> identity.</li>
              <li><strong><code>list</code> Operations as Morphisms:</strong> How list operations like <code>append</code> or transformations can be viewed as arrows acting on the single "list" object.</li>
          </ol>
      </div>

      <div class="chapter">
          <h2>5. Ok. Now, what's a database again? [TBD]</h2>
          <p class="chapter-intro">We've built some abstract machinery. Let's pivot back to our main topic: databases. How does this category theory stuff actually relate to tables, schemas, queries, and constraints? Time to look at familiar database concepts through our new categorical lens.</p>
          <ol>
              <li><strong>Tables as Sets (or Types):</strong> Revisiting the idea of database tables as sets of rows (or objects of a certain type).</li>
              <li><strong>Schemas as Graphs (Categories!):</strong> Representing a database schema (tables and foreign keys) as a graph, which we now recognize as potentially being a category.</li>
              <li><strong>Foreign Keys as Morphisms:</strong> How foreign key relationships naturally map to the idea of arrows connecting objects (tables).</li>
              <li><strong>Queries as Paths or Constructions:</strong> Thinking about SQL's <code>JOIN</code> as following paths in the schema graph, and queries as constructing new data based on these paths.</li>
          </ol>
      </div>

      <div class="chapter">
          <h2>6. Paths, Data constraints, Business Rules, all Facts! [TBD]</h2>
          <p class="chapter-intro">A database isn't just tables; it's the rules that govern the data. Constraints (<code>UNIQUE</code>, <code>NOT NULL</code>, <code>FOREIGN KEY</code>) and business logic ensure data integrity. Category theory provides a powerful way to express these rules as "facts" about the schema category, often involving paths and diagrams.</p>
          <ol>
              <li><strong>Paths in the Schema Category:</strong> Formally defining paths (sequences of morphisms/foreign keys) between tables.</li>
              <li><strong>Constraints as Statements about Paths:</strong> How a constraint might state that two different paths between tables must yield the same result (a "commutative diagram").</li>
              <li><strong>Modeling Business Rules:</strong> Representing more complex business logic using categorical diagrams or specific path requirements.</li>
              <li><strong>Commutative Diagrams: Declaring Facts:</strong> Introducing the idea that diagrams that "commute" (all paths between two objects compose to the same result) declare invariant truths about the data model.</li>
          </ol>
      </div>

      <div class="chapter">
          <h2>7. Data, the Schema category, and a Cat! (the category of small categories) [TBD]</h2>
          <p class="chapter-intro">Let's solidify the connection. If a database schema <em>is</em> a category (let's call it $\mathcal{C}$), what represents the actual <em>data</em>? Enter the functor! We'll see how a database instance is a functor from the schema category $\mathcal{C}$ to the category $Set$. And we'll even peek at $Cat$, the mind-bending category where categories themselves are objects!</p>
          <ol>
              <li><strong>The Schema Category $\mathcal{C}$:</strong> Formally defining the database schema (tables as objects, foreign keys as morphisms) as a category.</li>
              <li><strong>Database Instance as a Functor $I: \mathcal{C} \to Set$:</strong> The core idea: A functor maps each table (object) to the set of its rows, and each foreign key (morphism) to the actual function linking rows.</li>
              <li><strong>Data Integrity via Functoriality:</strong> How the functor definition automatically enforces foreign key constraints (the functions must respect the structure).</li>
              <li><strong>A Glimpse of $Cat$:</strong> Briefly introducing the Category of (Small) Categories. Why is this useful? (Think schema evolution, comparing different database models).</li>
          </ol>
          </div>

      <div class="chapter">
          <h2>8. Who is Grothendieck? Why everything is an RDF? [TBD]</h2>
          <p class="chapter-intro">Category theory's development owes much to Alexander Grothendieck, a mathematician with a vision for unifying structures. We'll briefly touch on his influence and then connect our database ideas to another universal data model: RDF (Resource Description Framework), the foundation of the Semantic Web. Is everything just a graph?</p>
          <ol>
              <li><strong>Grothendieck's Unifying Vision:</strong> A short appreciation of his work in algebraic geometry and category theory, emphasizing the search for fundamental structures.</li>
              <li><strong>RDF Triples: Subject-Predicate-Object:</strong> Introducing the basic building block of RDF and knowledge graphs.</li>
              <li><strong>RDF Graphs as Categories (or vice versa):</strong> How RDF graphs strongly resemble categorical diagrams. Can we model RDF using categories? Can we output categories <em>as</em> RDF?</li>
              <li><strong>The Universality of Graphs/Categories:</strong> Discussing the idea that many different kinds of structures can be represented effectively using these abstract graph-like concepts.</li>
          </ol>
      </div>

      <div class="chapter">
          <h2>9. How to build a safe reversible ETL [TBD]?</h2>
          <p class="chapter-intro">Extract, Transform, Load. ETL pipelines are the backbone of data warehousing and integration, but they can be complex and error-prone. Can category theory help us design ETL processes that are safer (structure-preserving) and maybe even reversible? Let's explore functors and natural transformations for ETL.</p>
          <ol>
              <li><strong>ETL as Functors between Schema Categories:</strong> Modeling the source and target schemas as categories ($\mathcal{C}_{source}$, $\mathcal{C}_{target}$) and the ETL process as a functor between them.</li>
              <li><strong>Ensuring Data Consistency during Transformation:</strong> How functor laws help guarantee that relationships in the source data are correctly mapped to the target.</li>
              <li><strong>Natural Transformations for Data Mapping:</strong> Introducing natural transformations as a way to map data <em>instances</em> (functors) between schemas, representing the "T" step.</li>
              <li><strong>Towards Reversibility: Isomorphisms and Adjunctions:</strong> Discussing conditions under which an ETL process might be reversible (e.g., using isomorphisms or pairs of adjoint functors), allowing data to flow back safely.</li>
          </ol>
           </div>

      <div class="chapter">
          <h2>10. What's the connection between Databases and Types? [TBD]</h2>
          <p class="chapter-intro">If you're a programmer, you live and breathe types. Database schemas also define types (column types, table structures). This final chapter explores the deep connection between database theory and type theory, often formalized using category theory, showing how schemas and types are two sides of the same structural coin.</p>
          <ol>
              <li><strong>Schemas as Type Systems:</strong> Viewing a database schema as a way of defining complex data types (the tables) and the relationships between them.</li>
              <li><strong>Constraints as Type Refinements:</strong> How database constraints correspond to more specific types (e.g., <code>VARCHAR(50) NOT NULL</code> is a refinement of <code>VARCHAR(50)</code>).</li>
              <li><strong>Functorial Semantics: Interpreting Schemas in Types:</strong> How categories can provide a formal semantics, interpreting database schemas within the category of types used by a programming language.</li>
              <li><strong>Dependent Types and Databases:</strong> A forward look at how more advanced type systems (like dependent types) might allow even tighter integration and verification between application code and database constraints.</li>
          </ol>
      </div>
    </div>
    <div class="social-links">
      Follow me on:
      <a href="https://x.com/jocerfranquiz" target="_blank">X.com</a> |
      <a href="https://www.linkedin.com/in/jocerfranquiz" target="_blank">LinkedIn</a>
    </div>
    <footer>
      <p>&copy; 2025 Jocer Franquiz</p>
    </footer>
</body>
</html>
